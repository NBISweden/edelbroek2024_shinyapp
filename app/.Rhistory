Time=mofa_object@covariates[[1]][1,])
p <- ggplot(plot_data, aes(y=Factor, x=Time)) +
geom_smooth(fill="gray75", col="black") +
geom_point(size=4, color="red") +
theme_light() +
labs(title=tmp_factor)
print(p)
}
if (!require("BiocManager", quietly = TRUE))
install.packages("BiocManager")
BiocManager::install("mixOmics")
packages <- c("mixKernel")
# Check and install missing packages
new_packages <- packages[!(packages %in% installed.packages()[,"Package"])]
if(length(new_packages)) install.packages(new_packages, dependencies = TRUE, type = "binary")
library(mixOmics)
library(mixKernel)
new_packages
packages
install.packages(packages)
library(mixOmics)
library(mixKernel)
install.packages(mixKernel)
install.packages("mixKernel")
if(!requireNamespace("BiocManager")){
install.packages("BiocManager")
}
BiocManager::install("phyloseq")
install.packages("mixKernel")
library(mixOmics)
library(mixKernel)
library(ggplot2)
set.seed(3)
n_points <- 200
x <- c(rnorm(n_points, mean = -4, sd = 1),
rnorm(n_points, mean = 4, sd = 1),
rnorm(n_points, mean = -4, sd = 1))
y <- c(rnorm(n_points, mean = -4, sd = 1),
rnorm(n_points, mean = 4, sd = 1),
rnorm(n_points, mean = -4, sd = 1),
rnorm(n_points, mean =4, sd = 1))
class <- factor(c(rep(0, each = 2 * n_points), rep(1, each = 2 * n_points)))
data <- data.frame(x, y, class)
plot(x,y,col=ifelse(data$class == 0, "red", "blue"))
## add kernel
data$z <- data$x * data$y
# Plotting in 3D
# Create an empty 3D plot
zlim <- range(data$z)
xlim <- range(data$x)
ylim <- range(data$y)
zmat <- matrix(NA, 2, 2)
trans <- persp(z = zmat, x = xlim, y = ylim, zlim = zlim, theta = 100, phi = 0,
axes = TRUE, box = TRUE, col = NA, border = NA, xlab = "x", ylab = "y", zlab = "z")
# Add the points with colors based on class
points(trans3d(data$x, data$y, data$z, pmat = trans), col = ifelse(data$class == 0, "red", "blue"), pch = 16)
# Add the separating line
lines (trans3d(0, y = ylim, z = 0, pmat = trans), col = 3,lwd=4)
# Simulate concentric circle data
set.seed(123)
n <- 500
r1 <- 1
r2 <- 6
theta <- runif(n, 0, 2*pi)
x1 <- r1*cos(theta) + rnorm(n, 0, 0.1)
y1 <- r1*sin(theta) + rnorm(n, 0, 0.1)
theta <- runif(n, 0, 2*pi)
x2 <- r2*cos(theta) + rnorm(n, 0, 0.3)
y2 <- r2*sin(theta) + rnorm(n, 0, 0.3)
data <- data.frame(
x = c(x1, x2),
y = c(y1, y2),
class = factor(rep(c(0,1), each=n))
)
plot(data$x,data$y,col=ifelse(data$class == 0, "red", "blue"))
data$z <- data$x * data$y
# Create an empty 3D plot
zlim <- range(data$z)
xlim <- range(data$x)
ylim <- range(data$y)
zmat <- matrix(NA, 2, 2)
par(mfrow=c(2,2))
trans <- persp(z = zmat, x = xlim, y = ylim, zlim = zlim, theta = 100, phi = 0,
axes = TRUE, box = TRUE, col = NA, border = NA, xlab = "x", ylab = "y", zlab = "z")
# Add the points with colors based on class
points(trans3d(data$x, data$y, data$z, pmat = trans), col = ifelse(data$class == 0, "red", "blue"), pch = 16)
trans <- persp(z = zmat, x = xlim, y = ylim, zlim = zlim, theta = 100, phi = 100,
axes = TRUE, box = TRUE, col = NA, border = NA, xlab = "x", ylab = "y", zlab = "z")
# Add the points with colors based on class
points(trans3d(data$x, data$y, data$z, pmat = trans), col = ifelse(data$class == 0, "red", "blue"), pch = 16)
trans <- persp(z = zmat, x = xlim, y = ylim, zlim = zlim, theta = 0, phi = 150,
axes = TRUE, box = TRUE, col = NA, border = NA, xlab = "x", ylab = "y", zlab = "z")
# Add the points with colors based on class
points(trans3d(data$x, data$y, data$z, pmat = trans), col = ifelse(data$class == 0, "red", "blue"), pch = 16)
trans <- persp(z = zmat, x = xlim, y = ylim, zlim = zlim, theta = 300, phi = 0,
axes = TRUE, box = TRUE, col = NA, border = NA, xlab = "x", ylab = "y", zlab = "z")
# Add the points with colors based on class
points(trans3d(data$x, data$y, data$z, pmat = trans), col = ifelse(data$class == 0, "red", "blue"), pch = 16)
sigma <- 0.5
data$z =exp(-rowSums(data[,1:2]^2) / (2 * sigma^2))
par(mfrow=c(1,1))
zlim <- range(data$z)
trans <- persp(z = zmat, x = xlim, y = ylim, zlim = zlim, theta = 120, phi = -13,
axes = TRUE, box = TRUE, col = NA, border = NA, xlab = "x", ylab = "y", zlab = "z")
points(trans3d(data$x, data$y, data$z, pmat = trans), col = ifelse(data$class == 0, "red", "blue"), pch = 16)
lines (trans3d(0, y = ylim, z = mean(c(max(min(data$z[data$class == 0])),max(min(data$z[data$class == 1])))), pmat = trans), col = 3,lwd=4)
sigma <- 0.5
kernel_matrix <- exp(-(as.matrix(dist(scale(data[,1:2]), method = "euclidean", diag = TRUE, upper = TRUE))^2) / (2*2 * sigma))
m <- dim(kernel_matrix)[1]
kernel_matrix.centered <- t(t(kernel_matrix - colSums(kernel_matrix)/m) - rowSums(kernel_matrix)/m) + sum(kernel_matrix)/m^2
egens <- eigen(kernel_matrix.centered, symmetric = TRUE)
pcscores_kernel <- t(t(egens$vectors[, 1:2])/sqrt(egens$values[1:2]))
pcscores_standard <- prcomp(data[,1:2])$x
par(mfrow=c(2,2))
plot(data[,1:2],col= ifelse(data$class == 0, "red", "blue"),main="original data")
plot(pcscores_standard[,1:2],col= ifelse(data$class == 0, "red", "blue"),main="standard pca",xlab="pc1",ylab="pc2")
plot(pcscores_kernel[,1:2],col= ifelse(data$class == 0, "red", "blue"),main="kernel pca",xlab="pc1",ylab="pc2")
# Download the dataset
download.file("https://github.com/mixOmicsTeam/mixOmics/raw/master/data/breast.TCGA.rda", destfile = "TCGA.rda")
# load the data
load("TCGA.rda")
str(breast.TCGA)
library(mixKernel)
library(mixOmics)
# calculate kernels for each data
mirna<-mixKernel::compute.kernel(breast.TCGA$data.train$mirna)
mrna<-mixKernel::compute.kernel(breast.TCGA$data.train$mrna)
protein<-mixKernel::compute.kernel(breast.TCGA$data.train$protein)
par(mfrow=c(1,1))
cim.kernel(mirna=mirna,mrna=mrna,protein=protein)
merged_kernel <- combine.kernels(mirna=mirna,mrna=mrna,protein=protein,
method = "full-UMKL")
merged_kpca <- kernel.pca(merged_kernel, ncomp = 2)
plotIndiv(merged_kpca,group=breast.TCGA$data.train$subtype,ind.names = F,ellipse = T,legend = T)
set.seed(123)
pca_variables <- kernel.pca.permute(merged_kpca,ncomp = 1,
mirna=colnames(mirna$X),mrna=colnames(mrna$X),protein=colnames(protein$X))
plotVar.kernel.pca(pca_variables, ndisplay = 10, ncol = 3)
e = 346 - 87
b=t
source("~/.active-rstudio-document")
v
length(v)
sum(v)
y
sum(y)
install.packages("text2speech")
library(text2speech)
sample(1:10)
sample(1,1:10)
sample(1:10,1)
while(TRUE){
x = sample(1:10,1)
y = sample(1:10,1)
# print(paste(x,"*",y"?"))
svar <- as.integer(readline(prompt = paste(x,"*",y"?")))
while(TRUE){
x = sample(1:10,1)
y = sample(1:10,1)
# print(paste(x,"*",y,"?"))
svar <- as.integer(readline(prompt = paste(x,"*",y, "?")))
if(svar == x*y){
print("RÄTT!")
}
else{
print("FEL!")
}
while(TRUE){
while(svar != x*y)
x = sample(1:10,1)
y = sample(1:10,1)
svar <- as.integer(readline(prompt = paste(x,"*",y, "?")))
if(svar == x*y){
break;
}
else{
print("FEL!")
}
source("~/.active-rstudio-document")
while(TRUE){
x = sample(1:10,1)
y = sample(1:10,1)
svar <- as.integer(readline(prompt = paste(x,"*",y, "?")))
while(svar != x*y){
svar <- as.integer(readline(prompt = paste(x,"*",y, "?")))
#if(svar != x*y)print("FEL!")
print
}
while(TRUE){
x = sample(1:10,1)
y = sample(1:10,1)
svar <- as.integer(readline(prompt = paste(x,"*",y, "?")))
print(c(x,y,svar))
while(svar != x*y){
svar <- as.integer(readline(prompt = paste(x,"*",y, "?")))
if(svar != x*y){
print("FEL!")
}
else{
print("RäTT!")
}
print
}
while(TRUE){
x = sample(1:10,1)
y = sample(1:10,1)
svar <- as.integer(readline(prompt = paste(x,"*",y, "?")))
while(svar != x*y){
svar <- as.integer(readline(prompt = paste(x,"*",y, "?")))
if(svar != x*y){
print("FEL!")
}
else{
print("RäTT!")
}
print
}
while(TRUE){
x = sample(1:10,1)
y = sample(1:10,1)
svar <- as.integer(readline(prompt = paste(x,"*",y, "?\n")))
while(svar != x*y){
svar <- as.integer(readline(prompt = paste(x,"*",y, "?\n")))
if(svar != x*y){
print("FEL!")
}
else{
print("RäTT!")
}
print
}
while(TRUE){
x = sample(1:10,1)
y = sample(1:10,1)
svar <- as.integer(readline(prompt = paste(x,"*",y, "?\n")))
while(svar != x*y){
svar <- as.integer(readline(prompt = paste(x,"*",y, "?\n")))
if(svar != x*y){
print("FEL!")
}
else{
print("RäTT!")
}
while(TRUE){
x = sample(1:10,1)
y = sample(1:10,1)
svar <- as.integer(readline(prompt = paste(x,"*",y, "?\n")))
while(svar != x*y){
svar <- as.integer(readline(prompt = paste(x,"*",y, "?\n")))
}
while(TRUE){
x = sample(1:10,1)
y = sample(1:10,1)
svar <- as.integer(readline(prompt = paste(x,"*",y, "?\n")))
while(svar != x*y){
svar <- as.integer(readline(prompt = paste(x,"*",y, "?\n")))
}
while(TRUE){
min_nr = 1
maxx_nr = 40
x = sample(min_nr:max_nr,1)
y = sample(min_nr:max_nr,1)
svar <- as.integer(readline(prompt = paste(x,"*",y, "?\n")))
while(svar != x*y){
svar <- as.integer(readline(prompt = paste(x,"*",y, "?\n")))
}
while(TRUE){
min_nr = 1
max_nr = 40
x = sample(min_nr:max_nr,1)
y = sample(min_nr:max_nr,1)
svar <- as.integer(readline(prompt = paste(x,"*",y, "?\n")))
while(svar != x*y){
svar <- as.integer(readline(prompt = paste(x,"*",y, "?\n")))
}
if (!require("BiocManager", quietly = TRUE))
install.packages("BiocManager")
BiocManager::install("coMethDMR")
library(coMethDMR)
library(UpSetR)
install.packages("UpSetR")
library(GeneStructureTools)
if (!require("BiocManager", quietly = TRUE))
install.packages("BiocManager")
BiocManager::install("GeneStructureTools")
library(karyoploteR)
library(BioCircos)
install.packages('BioCircos')
library(data.table)
library(minfi)
library(minfiData)
library(sva)
library(doParallel)
library(limma)
library(DMRcate)
library(tidyverse)
library(biomaRt)
library(ChIPpeakAnno)
library(EnsDb.Hsapiens.v75)
library(knitr)
library(kableExtra)
library(chipenrich)
if (!require("BiocManager", quietly = TRUE))
install.packages("BiocManager")
BiocManager::install("chipenrich")
library(missMethyl)
library(EpiDISH)
if (!require("BiocManager", quietly = TRUE))
install.packages("BiocManager")
BiocManager::install("EpiDISH")
library(viridis)
library(patchwork)
library(pheatmap)
library(rtracklayer)
library(ggplot2)
library(ggthemes)
library(tidyverse)
library(ggplot2)
library(ggthemes)
install.packages("ggthemes")
library(ggplot2)
library(ggthemes)
library(carData)
# Load the 'mtcars' dataset
data(mtcars)
# Create a scatter plot
ggplot(mtcars, aes(x = hp, y = mpg, color = as.factor(cyl))) +
geom_point() +
scale_color_manual(values = c("#E69F00", "#56B4E9", "#009E73")) +
theme_economist() +
labs(x = "Horsepower", y = "Miles per Gallon", title = "Scatter Plot: Horsepower vs. MPG", color = "Number of Cylinders")
shiny::runApp('shinyapp')
runApp('shinyapp')
# Shiny app for plotting RNA and protein data for Dictyostelium discoideum
#
# Jakub Orzechowski Westholm 2023-10-18
library(shiny)
library(DT)
library(grid)
library(gridExtra)
library(tidyverse)
# Creates a scatterplot of gene expression vs. time, and fits a loess curve
# to the data
# Input:
# - The id of the gene to plot
# - A gene expression table
# - An (optional) array annotating the data, mapping row names in the gene expression table to strings.
# - A sample sheet, with column "Minute"
# - An unit to use in the y-axis label, e.g. "mRNA", "protein" etc.
# - A string to to use in the caption, e.g. "mRNA", "protein" etc.
# - Span parameter for fitting the loess curve (default 0.6)
plot.gene <- function(geneId, geneExp, geneImpute, sampleSheet, dataAnnot=NULL, yaxisUnit="", caption = "", span = 0.6, legendPosition="none") {
sampleSheet <- sampleSheet[sampleSheet$Sample %in% colnames(geneExp),] # make sure samples match expression data
plotData <- data.frame(expLevel = t(geneExp[geneId,]),
imputed = t(geneImpute[geneId,]),
time = sampleSheet$Hours)
colnames(plotData) <- c("expLevel", "imputed", "time")
tmpSymbol <- ""
if(!is.null(dataAnnot)){
tmpSymbol <- dataAnnot[geneId]
if(is.na(tmpSymbol)){tmpSymbol <- "" }
}
ggplot(data = plotData, aes(x = time, y = expLevel, color=imputed, label)) + geom_point( size=3) +
scale_color_manual(values=c("black", "gray70")) +
geom_smooth(method = "loess", span = span, fill="gray80", color="gray40") + xlab("Time (Hours)") +
xlab("Time (Hours)") +
ylab(yaxisUnit) +
labs(title=caption,
subtitle=paste(geneId, tmpSymbol)) +
theme_classic() +
theme(axis.text.x = element_text(color="black"),
axis.text.y = element_text(color="black"),
plot.title = element_text(color="black", size=14, face="bold")) +
theme(legend.position=legendPosition)
}
# Average gene expression over groups of samples (e.g. cell cycle phase)
# Input:
# - A gene expression table
# - A list of arrays of column indexes, indicating which columns should be grouped together
# Output:
# - A new gene expression matrix, but with expression levels averged according to grouping given as input.
timePointAverages <- function(geneExp, timeGroups){
sapply(timeGroups,
function(x){
apply(geneExp[,intersect(x,colnames(geneExp))],1, mean, na.rm=T)
})
}
#############################
# Load data
#####
# Read gene annotations, downloaded from https://downloads.yeastgenome.org/curation/chromosomal_feature/SGD_features.tab
geneInfo <- read_tsv(file="shiny_data/gene_info.tsv", quote = "\"") %>%
mutate(Gene_products = replace_na(Gene_products, ""))
setwd('/Users/orzechoj/projects/soderbom_2020/dicty_analysis_scripts/f_soderbom_2005/shinyapp')
# Shiny app for plotting RNA and protein data for Dictyostelium discoideum
#
# Jakub Orzechowski Westholm 2023-10-18
library(shiny)
library(DT)
library(grid)
library(gridExtra)
library(tidyverse)
# Creates a scatterplot of gene expression vs. time, and fits a loess curve
# to the data
# Input:
# - The id of the gene to plot
# - A gene expression table
# - An (optional) array annotating the data, mapping row names in the gene expression table to strings.
# - A sample sheet, with column "Minute"
# - An unit to use in the y-axis label, e.g. "mRNA", "protein" etc.
# - A string to to use in the caption, e.g. "mRNA", "protein" etc.
# - Span parameter for fitting the loess curve (default 0.6)
plot.gene <- function(geneId, geneExp, geneImpute, sampleSheet, dataAnnot=NULL, yaxisUnit="", caption = "", span = 0.6, legendPosition="none") {
sampleSheet <- sampleSheet[sampleSheet$Sample %in% colnames(geneExp),] # make sure samples match expression data
plotData <- data.frame(expLevel = t(geneExp[geneId,]),
imputed = t(geneImpute[geneId,]),
time = sampleSheet$Hours)
colnames(plotData) <- c("expLevel", "imputed", "time")
tmpSymbol <- ""
if(!is.null(dataAnnot)){
tmpSymbol <- dataAnnot[geneId]
if(is.na(tmpSymbol)){tmpSymbol <- "" }
}
ggplot(data = plotData, aes(x = time, y = expLevel, color=imputed, label)) + geom_point( size=3) +
scale_color_manual(values=c("black", "gray70")) +
geom_smooth(method = "loess", span = span, fill="gray80", color="gray40") + xlab("Time (Hours)") +
xlab("Time (Hours)") +
ylab(yaxisUnit) +
labs(title=caption,
subtitle=paste(geneId, tmpSymbol)) +
theme_classic() +
theme(axis.text.x = element_text(color="black"),
axis.text.y = element_text(color="black"),
plot.title = element_text(color="black", size=14, face="bold")) +
theme(legend.position=legendPosition)
}
# Average gene expression over groups of samples (e.g. cell cycle phase)
# Input:
# - A gene expression table
# - A list of arrays of column indexes, indicating which columns should be grouped together
# Output:
# - A new gene expression matrix, but with expression levels averged according to grouping given as input.
timePointAverages <- function(geneExp, timeGroups){
sapply(timeGroups,
function(x){
apply(geneExp[,intersect(x,colnames(geneExp))],1, mean, na.rm=T)
})
}
#############################
# Load data
#####
# Read gene annotations, downloaded from https://downloads.yeastgenome.org/curation/chromosomal_feature/SGD_features.tab
geneInfo <- read_tsv(file="shiny_data/gene_info.tsv", quote = "\"") %>%
mutate(Gene_products = replace_na(Gene_products, ""))
geneId <- geneInfo %>% as.data.frame() %>% .[,2]
names(geneId) <- geneInfo %>% as.data.frame() %>% .[,1]
geneSymbol <- geneInfo %>% as.data.frame() %>% .[,3]
names(geneSymbol) <- geneInfo %>% as.data.frame() %>% .[,1]
geneDescShort <- geneInfo %>% as.data.frame() %>% .[,4]
names(geneDescShort) <- geneInfo %>% as.data.frame() %>% .[,1]
#####
# Load data
mRNAData <- read.table(file="shiny_data/rna_exp.tsv", sep="\t", header=T)
proteinData <- read.table(file="shiny_data/protein_exp.tsv", sep="\t", header=T)
proteinDataImputed <- read.table(file="shiny_data/protein_exp_is_imputed.tsv", sep="\t", header=T)
mRNADataInputed <- as.data.frame(mRNAData < 0) # data frame with only FALSE, since no RNA data is imputed
# Normalize so that the sum for each time point = the number of observations (RNAs or proteins)
norm_fun <- function(m){
m <- as.matrix(m)
m_norm <- log2(t(t(2^m)/apply(2^m,2,sum)))
return(as.data.frame(m_norm))
}
mRNAData <- norm_fun(mRNAData)
proteinData <- norm_fun(proteinData)
# Which samples to use, and which to leave out.
useRnaSamples <- colnames(mRNAData)
useProteinSamples <- colnames(proteinData)
useSamples <- sort(union(useRnaSamples, useProteinSamples))
sampleSheet <- data.frame(Sample=useSamples,
Hours=sapply(colnames(mRNAData), function(x){as.numeric(gsub("h", "", strsplit(x, "_")[[1]][2]))}))
allGenes <- names(geneId)
#####
# Load and format results from differential expression analysis
# mRNA - EXPAND THIS TABLE?
limmaRna <- right_join(geneInfo, read_tsv(file="shiny_data/rna_de_res.tsv"), by="UniProt_ID") %>%
dplyr::select(UniProt_ID, GENE_ID, Gene_Name, Gene_products, padj) %>%
mutate(padj = signif(padj,2))  %>%
mutate(padj = replace_na(padj, 1)) %>%
arrange(padj) %>%
as.data.frame()
rownames(limmaRna) <- limmaRna$UniProt_ID
# proteomics - EXPAND THIS TABLE?
limmaProt <- right_join(geneInfo, read_tsv(file="shiny_data/protein_de_res.tsv"), by="UniProt_ID") %>%
dplyr::select(UniProt_ID, GENE_ID, Gene_Name, Gene_products,adj.P.Val) %>%
rename(padj = adj.P.Val) %>%
mutate(padj = signif(padj,2)) %>%
mutate(padj = replace_na(padj, 1)) %>%
arrange(padj) %>%
as.data.frame()
rownames(limmaProt) <- limmaProt$UniProt_ID
# Write tables for download
# write.table(limmaRna, "www/mRNA_download.txt", sep="\t", row.names = FALSE)
# write.table(limmaProt, "www/protein_download.txt", sep="\t", row.names = FALSE)
#####
# Misc. hard coded parameters
startGene <- "Q552J0" # random gene here, CHANGE THIS!
pieRadius <- 2.5
loessSpan <- 0.6
tableHeight <- "450px"
write.table(limmaRna, "www/mRNA_download.txt", sep="\t", row.names = FALSE)
write.table(limmaProt, "www/protein_download.txt", sep="\t", row.names = FALSE)
runApp()
